name: Production Deployment

on:
  push:
    branches:
    - main

# –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–µ–ø–ª–æ–∏
concurrency:
  group: production-deploy
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: themacroeconomicdao/decentralized-social-platform/dsp-prod

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω—É–∂–Ω—ã–π —Ç–µ–≥ –æ–¥–∏–Ω —Ä–∞–∑, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ä–∞—Å—Å–∏–Ω—Ö—Ä–æ–Ω–∞
      - name: Set image tag
        id: vars
        run: echo "TAG=main-${GITHUB_SHA}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.TAG }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Verify image tag exists
        run: |
          sudo apt-get update && sudo apt-get install -y skopeo
          skopeo inspect docker://${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.TAG }} >/dev/null

      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Pre-deployment diagnostics
        run: |
          echo "üîç Pre-deployment cluster diagnostics:"
          echo "üìä Node resources:"
          kubectl top nodes || echo "‚ö†Ô∏è Metrics server unavailable"
          
          echo "üìã Current pods:"
          kubectl get pods -n default -l app=dsp-prod
          
          echo "üìà Current deployment status:"
          kubectl get deployment dsp-prod-deployment -n default -o wide
          
          echo "üîÑ ReplicaSets:"
          kubectl get rs -n default -l app=dsp-prod --sort-by=.metadata.creationTimestamp

      - name: Deploy to k3s
        run: |
          echo "üöÄ Starting deployment..."
          
          # Apply manifests via Kustomize overlay
          kubectl apply -k k8s/overlays/prod/

          # Update image in deployment to the specific new sha
          echo "üîÑ Updating deployment image..."
          kubectl set image deployment/dsp-prod-deployment dsp-prod=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.TAG }} -n default
          
          # Wait for rollout with detailed monitoring
          echo "‚è≥ Waiting for rollout to complete..."
          if ! kubectl rollout status deployment/dsp-prod-deployment -n default --timeout=300s; then
            echo "‚ùå Rollout failed! Gathering diagnostics..."
            
            echo "üìã Failed pods:"
            kubectl get pods -n default -l app=dsp-prod
            
            echo "üìù Recent events:"
            kubectl get events -n default --sort-by='.lastTimestamp' | tail -20
            
            echo "üîç Pod details for failed pods:"
            kubectl get pods -n default -l app=dsp-prod -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.phase}{"\t"}{.status.containerStatuses[0].state}{"\n"}{end}'
            
            echo "üíæ Describing problematic pods:"
            for pod in $(kubectl get pods -n default -l app=dsp-prod --field-selector=status.phase!=Running -o jsonpath='{.items[*].metadata.name}'); do
              echo "--- Pod: $pod ---"
              kubectl describe pod $pod -n default | tail -20
            done
            
            echo "üîÑ Rolling back deployment..."
            kubectl rollout undo deployment/dsp-prod-deployment -n default
            exit 1
          fi
          
          # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –∂–¥—ë–º –∞–≤—Ç–æ–º. –ø—Ä–æ–º–æ—É—Ç –∫–∞–Ω–∞—Ä–µ–µ—á–Ω–æ–≥–æ —Ä–µ–ª–∏–∑–∞ (Flagger)
          # –û–∂–∏–¥–∞–Ω–∏–µ –º–∞–∫—Å–∏–º—É–º 30–º–∏–Ω, –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –æ—à–∏–±–∫–µ (Flagger —Å–æ–∑–¥–∞—ë—Ç event canary.failed)
          # –ú–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å, –µ—Å–ª–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ Flagger
          echo "‚è≥ Waiting Flagger canary promotion (max 30m)..."
          kubectl -n default wait canary/dsp-prod --for=jsonpath='{.status.phase}'=Succeeded --timeout=1800s || true
          
          echo "‚úÖ Deployment completed successfully!"

      - name: Post-deployment verification
        run: |
          echo "üîç Post-deployment verification:"
          
          echo "üìä Final pod status:"
          kubectl get pods -n default -l app=dsp-prod -o wide
          
          echo "üåê Service status:"
          kubectl get svc dsp-prod-service -n default
          
          echo "üîó Ingress/Gateway status:"
          kubectl get gateway dsp-prod-gateway -n default || echo "No gateway found"
          kubectl get virtualservice -n default -l app=dsp-prod
          
          echo "üè• Health check:"
          for pod in $(kubectl get pods -n default -l app=dsp-prod -o jsonpath='{.items[*].metadata.name}'); do
            echo "Pod $pod readiness:"
            kubectl get pod $pod -n default -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}'
            echo ""
          done

      - name: Cleanup old ReplicaSets
        run: |
          echo "üßπ Cleaning up old ReplicaSets (keeping last 3)..."
          kubectl get rs -n default -l app=dsp-prod --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[*].metadata.name}' | tr ' ' '\n' | head -n -3 | xargs -r kubectl delete rs -n default

      # -------------------------------------------------
      # Telegram notifications
      # -------------------------------------------------
      - name: Notify Telegram success
        if: success()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_CHAT: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT}" \
            -d text="‚úÖ PROD deploy succeeded: $GITHUB_SHA by $GITHUB_ACTOR"

      - name: Notify Telegram failure
        if: failure()
        env:
          TG_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TG_CHAT: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
            -d chat_id="${TG_CHAT}" \
            -d text="‚ùå PROD deploy FAILED: $GITHUB_SHA. Check Actions logs."

      # -------------------------------------------------
      # Security scanning ‚Äî –ø–æ–∫–∞ –≤—ã–∫–ª—é—á–µ–Ω–æ, —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
      # -------------------------------------------------
      # - name: Trivy scan
      #   uses: aquasecurity/trivy-action@v0.19.0
      #   with:
      #     image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.TAG }}
      #     format: table
      #     exit-code: 0  # –Ω–µ –ø–∞–¥–∞–µ–º, –ø—Ä–æ—Å—Ç–æ –æ—Ç—á—ë—Ç

      # - name: Grype scan
      #   uses: anchore/scan-action@v3
      #   with:
      #     image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.TAG }}
      #     fail-build: false

